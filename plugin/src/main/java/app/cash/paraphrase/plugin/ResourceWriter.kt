/*
 * Copyright (C) 2023 Cash App
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package app.cash.paraphrase.plugin

import app.cash.paraphrase.plugin.model.MergedResource
import app.cash.paraphrase.plugin.model.MergedResource.Argument
import com.squareup.kotlinpoet.ANY
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.buildCodeBlock
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.ZonedDateTime
import kotlin.time.Duration

/**
 * Writes the given tokenized resources to a Kotlin source file.
 */
internal fun writeResources(
  packageName: String,
  mergedResources: List<MergedResource>,
): FileSpec {
  val packageStringsType = ClassName(packageName = packageName, "R", "string")
  val maxVisibility = mergedResources.maxOf { it.visibility }
  return FileSpec.builder(packageName = packageName, fileName = "FormattedResources")
    .addFileComment(
      """
        This code was generated by the Paraphrase Gradle plugin.
        Do not edit this file directly. Instead, edit the string resources in the source file.
      """.trimIndent(),
    )
    .addImport(packageName = packageName, "R")
    .addType(
      TypeSpec.objectBuilder("FormattedResources")
        .apply {
          mergedResources.forEach { mergedResource ->
            addFunction(mergedResource.toFunSpec(packageStringsType))
          }
        }
        .addModifiers(maxVisibility.toKModifier())
        .build(),
    )
    .build()
}

private fun MergedResource.toFunSpec(packageStringsType: TypeName): FunSpec {
  return FunSpec.builder(name.value)
    .apply { if (description != null) addKdoc(description) }
    .apply { arguments.forEach { addParameter(it.toParameterSpec()) } }
    .returns(Types.FormattedResource)
    .apply {
      if (hasContiguousNumberedTokens) {
        addCode(
          buildCodeBlock {
            add("val arguments = arrayOf(⇥\n")
            for (argument in arguments) {
              addStatement("%L,", argument.toParameterCodeBlock())
            }
            add("⇤)\n")
          },
        )
      } else {
        addStatement("val arguments = %T(%L)", Types.ArrayMap.parameterizedBy(STRING, ANY), arguments.size)
        for (argument in arguments) {
          addStatement("arguments.put(%S, %L)", argument.key, argument.toParameterCodeBlock())
        }
      }
    }
    .addCode(
      buildCodeBlock {
        add("return %T(⇥\n", Types.FormattedResource)
        addStatement("id = %T.%L,", packageStringsType, name.value)
        addStatement("arguments = arguments,")
        add("⇤)\n")
      },
    )
    .addModifiers(visibility.toKModifier())
    .build()
}

private fun Argument.toParameterSpec(): ParameterSpec =
  ParameterSpec(
    name = name,
    type = type.asClassName(),
  )

private fun Argument.toParameterCodeBlock(): CodeBlock =
  when (type) {
    Duration::class -> CodeBlock.of("%L.inWholeSeconds", name)
    LocalDate::class -> CodeBlock.of(
      "1000 * %T.of(%L, %T.NOON, %T.systemDefault()).toEpochSecond()",
      Types.ZonedDateTime,
      name,
      Types.LocalTime,
      Types.ZoneId,
    )
    LocalTime::class -> CodeBlock.of(
      "1000 * %T.of(%T.now(), %L, %T.systemDefault()).toEpochSecond()",
      Types.ZonedDateTime,
      Types.LocalDate,
      name,
      Types.ZoneId,
    )
    LocalDateTime::class -> CodeBlock.of(
      "1000 * %T.of(%L, %T.systemDefault()).toEpochSecond()",
      Types.ZonedDateTime,
      name,
      Types.ZoneId,
    )
    ZonedDateTime::class -> CodeBlock.of(
      "%T(%T.getTimeZone(%L.zone.id)).apply { timeInMillis = 1000 * %L.toEpochSecond() }",
      Types.GregorianCalendar,
      Types.TimeZone,
      name,
      name,
    )
    else -> CodeBlock.of("%L", name)
  }

private fun MergedResource.Visibility.toKModifier(): KModifier {
  return when (this) {
    MergedResource.Visibility.Public -> KModifier.PUBLIC
    MergedResource.Visibility.Private -> KModifier.INTERNAL
  }
}

private object Types {
  val ArrayMap = ClassName("android.util", "ArrayMap")
  val FormattedResource = ClassName("app.cash.paraphrase", "FormattedResource")
  val GregorianCalendar = ClassName("android.icu.util", "GregorianCalendar")
  val LocalDate = ClassName("java.time", "LocalDate")
  val LocalTime = ClassName("java.time", "LocalTime")
  val TimeZone = ClassName("android.icu.util", "TimeZone")
  val ZoneId = ClassName("java.time", "ZoneId")
  val ZonedDateTime = ClassName("java.time", "ZonedDateTime")
}
